\hypertarget{classmpu6050}{}\doxysection{mpu6050 Class Reference}
\label{classmpu6050}\index{mpu6050@{mpu6050}}


Class Mpu6050.  




{\ttfamily \#include $<$mpu6050.\+hpp$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classmpu6050_adc1ed3f6e889a4c49f3d4d8f178d7a9a}\label{classmpu6050_adc1ed3f6e889a4c49f3d4d8f178d7a9a}} 
{\bfseries mpu6050} (hwlib\+::i2c\+\_\+bus \&bus, uint16\+\_\+t address)
\item 
void \mbox{\hyperlink{classmpu6050_a62b5b93afa6a09478aabb733e2a52ff0}{start\+\_\+up}} ()
\begin{DoxyCompactList}\small\item\em Startup (no parameters) \end{DoxyCompactList}\item 
int16\+\_\+t \mbox{\hyperlink{classmpu6050_af11e9c670503341a73f6043312d1f940}{accel\+\_\+X}} ()
\begin{DoxyCompactList}\small\item\em Accelerometer X axis(no parameters) \end{DoxyCompactList}\item 
int16\+\_\+t \mbox{\hyperlink{classmpu6050_a50cf9818418b779456c98f574a76b6a6}{accel\+\_\+Y}} ()
\begin{DoxyCompactList}\small\item\em Accelerometer Y axis(no parameters) \end{DoxyCompactList}\item 
int16\+\_\+t \mbox{\hyperlink{classmpu6050_a6f5f7be8686b9a8ea774f589cb4a9341}{accel\+\_\+Z}} ()
\begin{DoxyCompactList}\small\item\em Accelerometer Z axis(no parameters) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classmpu6050_a9ca23e39236a6b6d57ce23ca838e5bed}{speed\+\_\+\+Test}} ()
\begin{DoxyCompactList}\small\item\em Speed Test(no parameters) \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Class Mpu6050. 

\begin{DoxyAuthor}{Author}
Nick Teeuwen 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
28/06/2021
\end{DoxyDate}
This is a microcontroller with a accelerometer and a gyroscope on it so you can calculate linaere acceleration and rotating acceleration. First we store the main addres of the Mpu6050 in the class and we store the i2c bus in the class(combined sda pin and scl pin). The appropriate constructors and operators are provided. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classmpu6050_af11e9c670503341a73f6043312d1f940}\label{classmpu6050_af11e9c670503341a73f6043312d1f940}} 
\index{mpu6050@{mpu6050}!accel\_X@{accel\_X}}
\index{accel\_X@{accel\_X}!mpu6050@{mpu6050}}
\doxysubsubsection{\texorpdfstring{accel\_X()}{accel\_X()}}
{\footnotesize\ttfamily int16\+\_\+t mpu6050\+::accel\+\_\+X (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Accelerometer X axis(no parameters) 

writes the high X axis Accel address to the chip so we can then read / saves the raw data from the X axis. and saves the high X in a byte Do the exact same with the low X accel as with the high X accel. Combine the 2 bytes to a 16byte instead of 8byte. The first byte gets shifted left because its the high byte. The combined bytes are put in a variable and the variable is returned. Note\+: this is the raw data \mbox{\Hypertarget{classmpu6050_a50cf9818418b779456c98f574a76b6a6}\label{classmpu6050_a50cf9818418b779456c98f574a76b6a6}} 
\index{mpu6050@{mpu6050}!accel\_Y@{accel\_Y}}
\index{accel\_Y@{accel\_Y}!mpu6050@{mpu6050}}
\doxysubsubsection{\texorpdfstring{accel\_Y()}{accel\_Y()}}
{\footnotesize\ttfamily int16\+\_\+t mpu6050\+::accel\+\_\+Y (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Accelerometer Y axis(no parameters) 

writes the high Y axis Accel address to the chip so we can then read / saves the raw data from the Y axis. and saves the high Y in a byte Do the exact same with the low Y accel as with the high Y accel. Combine the 2 bytes to a 16byte instead of 8byte. The first byte gets shifted left because its the high byte. The combined bytes are put in a variable and the variable is returned.\+Note\+: this is the raw data \mbox{\Hypertarget{classmpu6050_a6f5f7be8686b9a8ea774f589cb4a9341}\label{classmpu6050_a6f5f7be8686b9a8ea774f589cb4a9341}} 
\index{mpu6050@{mpu6050}!accel\_Z@{accel\_Z}}
\index{accel\_Z@{accel\_Z}!mpu6050@{mpu6050}}
\doxysubsubsection{\texorpdfstring{accel\_Z()}{accel\_Z()}}
{\footnotesize\ttfamily int16\+\_\+t mpu6050\+::accel\+\_\+Z (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Accelerometer Z axis(no parameters) 

writes the high Z axis Accel address to the chip so we can then read / saves the raw data from the Z axis. and saves the high Z in a byte Do the exact same with the low Z accel as with the high Z accel. Combine the 2 bytes to a 16byte instead of 8byte. The first byte gets shifted left because its the high byte. The combined bytes are put in a variable and the variable is returned. Note\+: this is the raw data \mbox{\Hypertarget{classmpu6050_a9ca23e39236a6b6d57ce23ca838e5bed}\label{classmpu6050_a9ca23e39236a6b6d57ce23ca838e5bed}} 
\index{mpu6050@{mpu6050}!speed\_Test@{speed\_Test}}
\index{speed\_Test@{speed\_Test}!mpu6050@{mpu6050}}
\doxysubsubsection{\texorpdfstring{speed\_Test()}{speed\_Test()}}
{\footnotesize\ttfamily void mpu6050\+::speed\+\_\+\+Test (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Speed Test(no parameters) 

First we get the value of the Z axis(accel\+\_\+\+Z) so we can determen our start point. Then we make a start point for the low value and the high value\textquotesingle{}s The low value gets -\/ 1500 and the high value + 1500. So we have a cap at what point the acceleration is higher then the basic air pressure. After all this we do the Start up function to wake the chip. If that is done we start a for loop and first check if the value the given value from the chip is higher then our high\+\_\+cap or lower then our low\+\_\+cap. So we can determen wich formule we need to use. After 1 of the 2 is true we quickly save the value of the current Z axis. Then we do the z axis value / 16384(16384 = 1 g force ) so we get the force of the acceleration in g force after. And at last we use the new g force value to calculate the speed in Km/H, 1 G = 34 km/h so we mutiply our value with 34 and we put a ABS over it so the value is alway positive. Extra Note\+: when we hold the chip horizontal there is already a output of a average of 1g on the chip because of gravity so it calulates that force also with the for of the impact. \mbox{\Hypertarget{classmpu6050_a62b5b93afa6a09478aabb733e2a52ff0}\label{classmpu6050_a62b5b93afa6a09478aabb733e2a52ff0}} 
\index{mpu6050@{mpu6050}!start\_up@{start\_up}}
\index{start\_up@{start\_up}!mpu6050@{mpu6050}}
\doxysubsubsection{\texorpdfstring{start\_up()}{start\_up()}}
{\footnotesize\ttfamily void mpu6050\+::start\+\_\+up (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Startup (no parameters) 

Writes 0 to 0x6B to wake up the \mbox{\hyperlink{classmpu6050}{mpu6050}} in case it is in sleeping mode so we can communicate with the \mbox{\hyperlink{classmpu6050}{mpu6050}}. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{mpu6050_8hpp}{mpu6050.\+hpp}}\end{DoxyCompactItemize}
